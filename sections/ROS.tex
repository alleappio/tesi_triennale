\section{ROS}
In questa sezione si passa alla descrizione di ROS, al suo funzionamento e al suo utilizzo.

\subsection{Descrizione}
Il Robotic Operating System, comunemente abbreviato in ROS, rappresenta un framework software di riferimento nel panorama della robotica. Si tratta di una suite di librerie e strumenti open-source progettata per semplificare e accelerare lo sviluppo di applicazioni complesse destinate a sistemi robotici di varia natura. ROS offre un'infrastruttura flessibile e modulare che consente agli sviluppatori di creare, testare e distribuire software in modo efficiente.

\noindent La scelta della versione di ROS è strettamente correlata alla distribuzione Linux utilizzata. In ambito robotico, Ubuntu è il sistema operativo più diffuso grazie alla sua stabilità e al supporto a lungo termine. Nel contesto del presente lavoro, è stata selezionata la distribuzione Ubuntu 20.04 Focal Fossa, in quanto rappresenta l'ultima versione LTS (Long Term Support) compatibile con la scheda grafica GPGPU adottata come computer di bordo.

\noindent In linea con questa scelta, è stata adottata la versione ROS2 Foxy Fitzroy che, Rispetto alla precedente generazione ROS1 (Noetic Ninjemys), introduce una serie di miglioramenti significativi, tra cui:

\begin{itemize}
  \item Supporto multi-linguaggio: ROS2 offre un supporto più ampio per diversi linguaggi di programmazione, tra cui C++ e Python. Tuttavia, nel caso specifico di questo progetto, si è optato per l'utilizzo esclusivo del C++ al fine di ottenere un controllo più granulare sul codice e sfruttare le elevate prestazioni offerte da questo linguaggio.
  \item Modernizzazione delle librerie: Le librerie di ROS2 sono state aggiornate e ampliate, offrendo funzionalità più avanzate e una maggiore integrazione con altri strumenti software.
  \item Architettura distribuita e scalabile: ROS2 è progettato per gestire sistemi robotici complessi e distribuiti, con una maggiore attenzione alla scalabilità e alla resilienza.
\end{itemize}

\noindent Nel corso di questa tesi tutta l'implementazione sarà svolta in linguaggio C++, questa decisione è stata guidata da diversi fattori:

\begin{itemize}
  \item Controllo a basso livello: Il C++ consente un controllo più preciso sulle risorse hardware e software del sistema, permettendo di ottimizzare le prestazioni e di implementare algoritmi complessi in modo efficiente
  \item Prestazioni elevate: Il C++ è noto per le sue elevate prestazioni, che sono fondamentali in applicazioni robotiche real-time dove la latenza e la capacità di risposta del sistema sono critiche
  \item Ampia diffusione e supporto: Il C++ è un linguaggio di programmazione molto diffuso nel settore della robotica, con una vasta comunità di sviluppatori e una ricca gamma di librerie e strumenti a disposizione
\end{itemize}

\noindent Il pacchetto ROS, oltre a fornire le componenti software di base, offre un ampio ventaglio di strumenti per lo sviluppo e il debugging. Tra questi, RViz (ROS-Visualization) riveste un ruolo cruciale, fornendo una potente interfaccia di visualizzazione tridimensionale. Progettato specificatamente per operare all'interno dell'ecosistema ROS, RViz consente agli sviluppatori di visualizzare in modo intuitivo e dettagliato i dati provenienti dai sensori e dagli attuatori del robot. Durante la fase di sviluppo, RViz è stato utilizzato in modo estensivo per la visualizzazione dei dati di telemetria, facilitando la comprensione del funzionamento del sistema e l'individuazione di eventuali anomalie. La sua capacità di rappresentare in modo grafico le informazioni provenienti da diversi nodi del sistema ha reso RViz uno strumento indispensabile per la messa a punto e la validazione degli algoritmi di localizzazione.

\subsection{Nodi}
\noindent Uno degli aspetti fondamentali di ROS è la sua architettura basata su nodi, che rappresentano unità di esecuzione autonome all'interno del sistema. Un nodo può essere responsabile di una vasta gamma di funzioni, tra cui eseguire calcoli, interfacciarsi con dispositivi hardware, raccogliere dati dai sensori, e molto altro. Tuttavia, la caratteristica più distintiva di un nodo ROS è la sua capacità di comunicare in maniera integrata con altri nodi attraverso un sistema di messaggistica distribuita. Questo sistema consente ai nodi di scambiare informazioni in tempo reale, permettendo una coordinazione precisa e affidabile tra i diversi componenti di un robot.

\noindent Questa struttura modulare e comunicativa rende possibile la rappresentazione di ciascuna funzione operativa del robot come un nodo distinto, favorendo una chiara separazione delle responsabilità e una maggiore facilità di sviluppo e manutenzione. Ad esempio, lo stack software utilizzato per il controllo autonomo del rover all'interno di questo progetto è costituito da una serie di nodi ROS, ognuno dei quali svolge un ruolo specifico e critico nel funzionamento complessivo del sistema.

\noindent I principali nodi che compongono questo stack sono i seguenti:

\begin{itemize}
  \item \textbf{hunter\_ros2\_node}: Questo nodo è responsabile della gestione della comunicazione tra i vari nodi ROS e l'interfaccia CAN (Controller Area Network) del veicolo. Attraverso questo nodo, i comandi e le informazioni vengono trasmessi efficacemente tra il sistema di controllo e il rover, assicurando un'interazione fluida e coerente con l'hardware del veicolo

  \item \textbf{urg\_node}: Il compito di questo nodo è quello di raccogliere e trasmettere le informazioni provenienti dal sensore Lidar agli altri nodi del sistema. La scansione dell'ambiente effettuata dal Lidar viene elaborata e distribuita, fornendo dati essenziali per la navigazione autonoma e l'evitamento degli ostacoli

  \item \textbf{particle\_filter}: Questo nodo implementa un algoritmo di localizzazione basato su filtri particellari, che consente di determinare con precisione la posizione del rover rispetto alla mappa dell'ambiente circostante. Il nodo utilizza le informazioni della mappa e le scansioni del sensore Lidar per aggiornare continuamente la stima della posizione del veicolo

  \item \textbf{telemetry\_node} e \textbf{control\_node}: Questi nodi gestiscono la comunicazione tra ROS e il protocollo MQTT (Message Queuing Telemetry Transport), garantendo la trasmissione di dati di telemetria e comandi di controllo in modo efficiente e affidabile
\end{itemize}

\noindent Tutti questi nodi operano in sinergia, scambiandosi informazioni critiche attraverso il sistema di messaggistica ROS, contribuendo all'esecuzione coordinata delle funzioni del robot. Questo approccio modulare e interconnesso consente di affrontare in modo efficiente le complesse esigenze operative del rover, garantendo una gestione robusta e scalabile delle diverse attività richieste durante la sua operazione autonoma e remota.
\subsection{Comunicazione tra nodi}
Sorge però spontaneo domandarsi come questi nodi comunichino tra loro e come facciamo soprattutto a riconoscere di che tipo di informazione si tratti.
Una comunicazione ROS è formata da 3 elementi:
\begin{itemize}
  \item Topic: Il protocollo utilizzato da ROS è di tipo publish/subscribe, ciò vuol dire che durante l'esecuzione dei nodi si vanno a creare dei topic, ovvero stringhe che utilizzano come separatore il carattere '/' e che ci permettono di suddividere tutti i diversi dati da inviare. Un esempio sono le scan lidar che vengono pubblicate sul topic "/scan". Ogni nodo può decidere se fare la subscribe a quel nodo (ovvero ricevere tutti i dati inviati attraverso esso), fare delle publish (ovvero pubblicare dati su di esso) o se semplicemente ignorarlo
  \item Message type: Una volta scelto un topic però si dovrà anche decidere quali informazioni saranno ammesse su questo, ROS fornisce diversi tipi di dato pubblicabile su un singolo topic. Un esempio è il tipo di dato utilizzato dal particle filter e dall'odometria del mezzo, ovvero "Odometry messages", che descrivono la posizione e il movimento (o meglio l'odometria) di un oggetto nello spazio. Il messaggio specifico per l'odometria fornito da ROS è strutturanto nel seguente modo:

    \begin{forest}
      %for tree={grow'=90, circle, draw, l sep=5pt}
      for tree={draw}
      [Odometry
        [Header
          [timestamp]
        ]
        [Pose\_with\_covariance
          [Pose
            [Position
              [x]
              [y]
              [z]
            ]
            [Orientation
              [x]
              [y]
              [z]
              [w]
            ]
          ]
          [Covariance]
        ]
        [twist\_with\_covariance
          [Twist
            [Linear\_velocity
              [x]
              [y]
              [z]
            ]
            [Angular\_velocity
              [x]
              [y]
              [z]
            ]
          ]
          [Covariance]
        ]
      ]
    \end{forest}

  \noindent In questo particolare messaggio come si può notare sono contenuti: la posa, ovvero la posizione e l'orientamento del veicolo rispetto al punto di partenza, ed il Twist ovvero la velocità lineare e quella angolare dell'oggetto al momento della misura.
  \noindent Esistono molti tipi di dato forniti da ROS alcuni altri esempi sono l'ackermann message: che fornisce come dati principali una velocità ed un angolo di sterzo e viene utilizzato per comunicare al robot il movimento da compiere. Tutti i tipi di messaggio sono consultabili online sulla documentazione di ROS 
  \item Content: è il dato che dobbiamo inviare e che deve essere incapsulato nel tipo di dato fornitoci da ROS
\end{itemize}
